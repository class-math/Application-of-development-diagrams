<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>æœ€å¤§ç«‹æ–¹ä½“ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ V6 (å®Œå…¨ç‰ˆ)</title>
    <style>
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; background: #eef2f3; margin: 0; padding: 20px; }
        .container { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; }
        canvas { background: white; border: 3px solid #333; cursor: grab; touch-action: none; border-radius: 4px; }
        canvas:active { cursor: grabbing; }
        .controls { background: white; padding: 20px; border-radius: 12px; width: 350px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); }
        .slider-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; color: #444; }
        select, input[type="range"] { width: 100%; margin-bottom: 10px; }
        .status-box { padding: 12px; border-radius: 8px; text-align: center; font-weight: bold; margin-top: 10px; border: 2px solid transparent; }
        .ok { background: #e8f5e9; color: #2e7d32; border-color: #2e7d32; }
        .ng { background: #ffebee; color: #c62828; border-color: #c62828; }
        .snap-info { background: #fff9c4; padding: 8px; font-size: 0.85em; border-radius: 5px; margin-bottom: 10px; border: 1px solid #fbc02d; }
    </style>
</head>
<body>

    <h1>æœ€å¼·ã®å±•é–‹å›³ã‚’æ¢ã›ï¼V6</h1>
    
    <div class="container">
        <canvas id="canvas" width="600" height="600"></canvas>

        <div class="controls">
            <div class="snap-info">ğŸ’¡ è§’åº¦ãŒ0Â°/90Â°/180Â°/270Â°ã®ã¨ãã€æ–¹çœ¼ã«ãƒ”ã‚¿ãƒƒã¨å¸ç€ã—ã¾ã™ï¼</div>
            
            <div class="slider-group">
                <label>1. ç´™ã®ã‚µã‚¤ã‚ºã‚’é¸æŠ:</label>
                <select id="paperType">
                    <option value="10,10">10cm Ã— 10cm</option>
                    <option value="20,20">20cm Ã— 20cm</option>
                    <option value="20,10">20cm Ã— 10cm (æ¨ªé•·)</option>
                </select>
            </div>

            <div class="slider-group">
                <label>2. å±•é–‹å›³ã®å½¢:</label>
                <select id="netType"></select>
            </div>

            <div class="slider-group">
                <label>3. 1è¾ºã®é•·ã•: <span id="sideLenVal">2.50</span> cm</label>
                <input type="range" id="sideLen" min="1" max="6.5" step="0.01" value="2.5">
            </div>

            <div class="slider-group">
                <label>4. å›è»¢è§’åº¦: <span id="angleVal">0</span>Â°</label>
                <input type="range" id="angle" min="0" max="360" step="1" value="0">
            </div>

            <div id="status" class="status-box ok">åˆ¤å®š: OK</div>
            
            <div style="margin-top:15px; font-size: 1.1em;">
                ç¾åœ¨ã®ä½“ç©: <strong><span id="volume">15.63</span> cmÂ³</strong>
            </div>
        </div>
    </div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let paperW = 10, paperH = 10;
let SCALE = 40;
const SNAP_THRESHOLD = 8; // å¸ç€æ„Ÿåº¦

const nets = {
    "1-4-1å‹ (åå­—)": [[0,-1],[0,0],[0,1],[0,2],[-1,0],[1,0]],
    "2-3-1å‹ (éšæ®µ)": [[0,0],[1,0],[2,0],[0,1],[-1,1],[1,-1]],
    "3-3å‹ (ãƒ„ã‚¤ãƒ³)": [[0,0],[1,0],[2,0],[-1,1],[0,1],[1,1]],
    "2-2-2å‹": [[0,0],[1,0],[1,1],[2,1],[2,2],[3,2]],
    "1-3-2å‹": [[0,0],[0,1],[0,2],[1,2],[1,3],[-1,2]]
};

const selectNet = document.getElementById('netType');
Object.keys(nets).forEach(key => {
    const opt = document.createElement('option');
    opt.value = key; opt.textContent = key;
    selectNet.appendChild(opt);
});

let posX = canvas.width / 2, posY = canvas.height / 2;
let isDragging = false;
let isSnapped = false;

function draw() {
    [paperW, paperH] = document.getElementById('paperType').value.split(',').map(Number);
    const s = parseFloat(document.getElementById('sideLen').value);
    const angleDeg = parseInt(document.getElementById('angle').value);
    const a = angleDeg * Math.PI / 180;
    const net = nets[selectNet.value];

    SCALE = (paperW > 10 || paperH > 10) ? 25 : 45;
    const offsetX = (canvas.width - paperW * SCALE) / 2;
    const offsetY = (canvas.height - paperH * SCALE) / 2;

    document.getElementById('sideLenVal').textContent = s.toFixed(2);
    document.getElementById('angleVal').textContent = angleDeg;
    document.getElementById('volume').textContent = Math.pow(s, 3).toFixed(2);

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // ç´™ã¨æ–¹çœ¼ã®æç”»
    ctx.strokeStyle = '#333'; ctx.lineWidth = 2;
    ctx.strokeRect(offsetX, offsetY, paperW * SCALE, paperH * SCALE);
    ctx.strokeStyle = '#eee'; ctx.lineWidth = 1;
    for(let i=0; i<=paperW; i++){ ctx.beginPath(); ctx.moveTo(offsetX+i*SCALE, offsetY); ctx.lineTo(offsetX+i*SCALE, offsetY+paperH*SCALE); ctx.stroke(); }
    for(let j=0; j<=paperH; j++){ ctx.beginPath(); ctx.moveTo(offsetX, offsetY+j*SCALE); ctx.lineTo(offsetX+paperW*SCALE, offsetY+j*SCALE); ctx.stroke(); }

    // ã‚¹ãƒŠãƒƒãƒ—è¨ˆç®—ï¼ˆç›´è§’å›è»¢æ™‚ã®ã¿ï¼‰
    isSnapped = false;
    if (angleDeg % 90 === 0) {
        let minDiffX = Infinity, minDiffY = Infinity;
        net.forEach(square => {
            [[0,0],[1,0],[1,1],[0,1]].forEach(corner => {
                const rx = (square[0] + corner[0]) * s * SCALE;
                const ry = (square[1] + corner[1]) * s * SCALE;
                const curX = rx * Math.cos(a) - ry * Math.sin(a) + posX;
                const curY = rx * Math.sin(a) + ry * Math.cos(a) + posY;

                for(let i=0; i<=paperW; i++) {
                    let gx = offsetX + i*SCALE;
                    if(Math.abs(curX - gx) < SNAP_THRESHOLD && Math.abs(curX - gx) < Math.abs(minDiffX)) minDiffX = gx - curX;
                }
                for(let j=0; j<=paperH; j++) {
                    let gy = offsetY + j*SCALE;
                    if(Math.abs(curY - gy) < SNAP_THRESHOLD && Math.abs(curY - gy) < Math.abs(minDiffY)) minDiffY = gy - curY;
                }
            });
        });
        if(Math.abs(minDiffX) < SNAP_THRESHOLD) { posX += minDiffX; isSnapped = true; }
        if(Math.abs(minDiffY) < SNAP_THRESHOLD) { posY += minDiffY; isSnapped = true; }
    }

    // ã¯ã¿å‡ºã—åˆ¤å®š
    let isOut = false;
    net.forEach(square => {
        [[0,0],[1,0],[1,1],[0,1]].forEach(corner => {
            const rx = (square[0] + corner[0]) * s * SCALE;
            const ry = (square[1] + corner[1]) * s * SCALE;
            const finalX = rx * Math.cos(a) - ry * Math.sin(a) + posX;
            const finalY = rx * Math.sin(a) + ry * Math.cos(a) + posY;
            if (finalX < offsetX - 0.5 || finalX > offsetX + paperW * SCALE + 0.5 ||
                finalY < offsetY - 0.5 || finalY > offsetY + paperH * SCALE + 0.5) isOut = true;
        });
    });

    // ã‚¹ãƒŠãƒƒãƒ—æ™‚ã®ã‚¬ã‚¤ãƒ‰æ æç”»
    if(isSnapped) {
        ctx.strokeStyle = '#ffa726'; ctx.lineWidth = 3;
        ctx.strokeRect(offsetX, offsetY, paperW * SCALE, paperH * SCALE);
    }

    // å±•é–‹å›³æç”»
    ctx.save();
    ctx.translate(posX, posY); ctx.rotate(a);
    ctx.fillStyle = isOut ? 'rgba(244,67,54,0.5)' : 'rgba(33,150,243,0.5)';
    ctx.strokeStyle = isOut ? '#d32f2f' : '#1976d2';
    net.forEach(sq => {
        ctx.fillRect(sq[0]*s*SCALE, sq[1]*s*SCALE, s*SCALE, s*SCALE);
        ctx.strokeRect(sq[0]*s*SCALE, sq[1]*s*SCALE, s*SCALE, s*SCALE);
    });
    ctx.restore();

    const st = document.getElementById('status');
    st.textContent = isOut ? "åˆ¤å®š: ã¯ã¿å‡ºã—" : "åˆ¤å®š: OK";
    st.className = "status-box " + (isOut ? "ng" : "ok");
}

function updatePos(e) {
    const rect = canvas.getBoundingClientRect();
    posX = (e.clientX || (e.touches && e.touches[0].clientX)) - rect.left;
    posY = (e.clientY || (e.touches && e.touches[0].clientY)) - rect.top;
    draw();
}

canvas.addEventListener('mousedown', (e) => { isDragging = true; updatePos(e); });
window.addEventListener('mouseup', () => isDragging = false);
canvas.addEventListener('mousemove', (e) => { if(isDragging) updatePos(e); });
canvas.addEventListener('touchstart', (e) => { isDragging = true; updatePos(e); e.preventDefault(); }, {passive:false});
canvas.addEventListener('touchmove', (e) => { if(isDragging) updatePos(e); e.preventDefault(); }, {passive:false});
canvas.addEventListener('touchend', () => isDragging = false);
document.querySelectorAll('input, select').forEach(el => el.addEventListener('input', draw));
draw();
</script>
</body>
</html>
